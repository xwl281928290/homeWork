<!--
 * @Author: Mr.xie
 * @Date: 2021-07-21 16:26:13
 * @LastEditTime: 2021-07-27 15:30:09
 * @LastEditors: Mr.xie
 * @Description: 
 * @FilePath: /homeWork/js进阶/js常见知识点.md
 * 可以输入预定的版权声明、个性签名、空行等
-->

# 常用正则表达式
    // （1）匹配 16 进制颜色值
    var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;

    // （2）匹配日期，如 yyyy-mm-dd 格式
    var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;

    // （3）匹配 qq 号
    var regex = /^[1-9][0-9]{4,10}$/g;

    // （4）手机号码正则
    var regex = /^1[34578]\d{9}$/g;

    // （5）用户名正则
    var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$/;

# javascript 创建对象的几种方式？
        我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js
    和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象
    创建方式，我了解到的方式有这么几种：

    （1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。

    （2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。

    （3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

    （4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。

    （5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。

    （6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。


# 35、JavaScript 继承的几种实现方式？

    （1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

    （2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

    （3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

    （4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

    （5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

    （6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

# 谈谈 This 对象的理解
    1 函数调用：
        当一个函数不是一个对象的属性时 直接作为函数调用 this指向全局对象
    2 方法调用：
        当一个函数做一个一个对象的方法来掉哟个时 this 指向这个对象
    3 构造器：
        当一个函数用new调用时 函数执行会新创建一个对象 this指向这个新创建的对象
    4 apply call bind
        1）三种都可以显示的指定调用函数的this指向
        2）apply俩参数 this绑定对象 参数数组
        3）call 俩参数 this绑定对象 传入函数执行的参数
        4）bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。
            这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变
    优先级：
        构造器 》apply。。》方法调用 》函数调用

# eval 是做什么的
    功能：把对应的字符串解析程js代码并运行
    缺点：缺点 不安全 且性能不高 一次解析程js与 一次执行

# 什么是闭包 为什么要用它
    含义：指有权访问另一个函数作用域中变量的函数
    用途：
        1 创建私有变量：
            通过闭包 在外部调用闭包函数 在外部访问函数内部变量
        2 使已经结束的函数上下文中的变量对象继续留在内存中 
            因为闭包保留了这个变量对象的引用 这个变量对象不会被回收
    案例：
        <script type="text/javascript">
            var divs = document.getElementsByTagName("div");
            for (var i = 0; i < divs.length; i++) {
                // 没有使用闭包 每次打印都是最后一个
                // divs[i].onclick = function () {
                //     alert(i);
                // }

                // 使用闭包
                (function (i) {
                    divs[i].onclick = function () {
                        alert(i);
                    }
                })(i)
            }
        </script>
# instanceof 的作用？
    作用：
        判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
    案例：
        function myInstanceof(left, right) {
            let proto = Object.getPrototypeOf(left), // 获取对象的原型
                prototype = right.prototype; // 获取构造函数的 prototype 对象

            // 判断构造函数的 prototype 对象是否在对象的原型链上
            while (true) {
                if (!proto) return false;
                if (proto === prototype) return true;
                proto = Object.getPrototypeOf(proto);
            }
        }

# js中 有一个函数 执行对象查询时 永远不会去查询原型 这个函数是
    hasOwnProperty：
        1 所有继承了Object的对象都会继承到 hasOwnProperty方法 
        2 这个方法可以用来检测一个对象是否含有特定的自身属性 和 in运算不同 
        3 该方法会忽略掉那些从原型链上继承到的属性
    案例：
        function Test() {
            this.name = '自有属性'
        }
        Test.prototype.name = '继承属性'

        var f = new Test();
        console.log(f.hasOwnProperty('name')) //true 是自有属性
        console.log(f.name) //自有属性

# js的几种模块规范

# .call() 和 .apply() 的区别？

# 简单介绍一下 V8 引擎的垃圾回收机制

# 数组和对象有那些原生方法
    数组和字符串转换：
        toString，toLocalString，join
    尾部：删除/添加
        pop，push
    头部：删除/添加
        shift，unshift
    反转：
        reverse()
    排序：
        sort( (x,y) => return x-y)
    连接：
        concat
    截取：
        slice //slice(0, 3) 0角标开始 向后3位
    插入：
        splice
    影响索引：
        indexOf，lastIndexOf
    迭代方法：
        every some filter map forEach
    归并：
        reduce reduceRight

# 那些操作会造成内存泄漏
    内存泄漏：
        就是没有使用，或已经使用完的变量，没有及时回收。
    1 意外的全局变量
        1）函数内部初始化但是没有声明的变量 会变成全局变量
        2）由this创建的全局变量
        function f1(){
            //初始化这个变量没有声明，成为全局变量，不会自动被回收
            bar = "this is a global variable"
            //window.bar = "this is a global variable"
        }
        注意：有些全局变量产生的垃圾，不可回收，尤其当全局变量用于临时存储和处理大量信息的时候，
            确保用完之后将他设置为null
    2 被遗忘的计时器和回掉函数
    3 脱离dom的引用
        dom清空或删除时，事件未清除导致的内存泄漏
    4 闭包
        不合理的使用闭包，从而导致某些变量一直被留在内存当中

# polyfill
    含义：用于实现浏览器并不支持的原声api的代码
    案例：
        querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。

# Object.is() 与原来的比较操作符 “===”、“==” 的区别？
    ==: 类型不一致时 会先强制类型转化后再进行比较。
    ===：比较严格 不能进行隐式类型转换
    object.is:
        1 Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 
            不再相同，但 Object.is(NaN, NaN) 会返回 true
        2 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。
        
# Unicode 和 UTF-8 之间的关系？
    unicode：
         是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。
    UTF-8：
         是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。


# js深浅拷贝实现
    // 浅拷贝的实现;
    function shallowCopy(object) {
        // 只拷贝对象
        if (!object || typeof object !== "object") return;
        // 根据 object 的类型判断是新建一个数组还是对象
        let newObject = Array.isArray(object) ? [] : {};
        // 遍历 object，并且判断是 object 的属性才拷贝
        for (let key in object) {
            if (object.hasOwnProperty(key)) {
                newObject[key] = object[key];
            }
        }
        return newObject;
    }

    // 深拷贝的实现;

    function deepCopy(object) {
        if (!object || typeof object !== "object") return;
        let newObject = Array.isArray(object) ? [] : {};
        for (let key in object) {
            if (object.hasOwnProperty(key)) {
            newObject[key] =
                typeof object[key] === "object" ? deepCopy(object[key]) : object[key];
            }
        }
        return newObject;
    }

# 为什么 0.1 + 0.2 != 0.3？如何解决这个问题
    原因：
        1 计算机中所有的数据最后都是以二进制形式保存
        2 01和0，2在转换为二进制的时候出现了位数无限循环 
        3 二进制中浮点数 最多保留小数点后 52位 所以精度丢失
    解决：
        (a * 100 + b * 100) / 100
