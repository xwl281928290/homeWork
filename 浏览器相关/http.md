<!--
 * @Author: Mr.xie
 * @Date: 2021-07-15 08:47:00
 * @LastEditTime: 2021-07-28 15:37:09
 * @LastEditors: Mr.xie
 * @Description: 
 * @FilePath: /homeWork/浏览器相关/http.md
 * 可以输入预定的版权声明、个性签名、空行等
-->


# http状态码 
    数字分类：
        1 表示信息
        2 表示成功
        3 重定向
        4 客户端错误
        5 服务器错误
    具体：
        200:成功
        301:永久重定向
        302:临时重定向
        304:未修改 请求缓存
        403:服务器得到请求 但是拒绝执行
# osi七层模型
    应用层：文件传输 常用协议HTTP，snmp，FTP
    表示层：数据格式化 代码转换 数据加密
    会话层：建立 解除会话
    传输层：提供端对端的接口 tcp udp
    网络层：为数据报选择路由 icmp
    数据链路层：传输有地址的帧
    物理层：二进制的数据形式在物理媒体上传输数据

# 从url到显示页面过程发生了什么
    1 DNS解析
    2 Tcp连接
    3 发送HTTP请求
    4 服务器处理请求并返回HTTP报文
    5 浏览器解析渲染页面
    6 连接结束

# http 和 https 区别
    1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，
        一般免费证 书较少，因而需要一定费用。(以前网易官网是 HTTP，而网易邮箱是 HTTPS 。) 
    2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协 议
    3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者 是 443 
    4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密 传输、身份认证的网络协议，比 HTTP 协议安全。
        (无状态的意思是其数据包的发送、传输 和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

# 浏览器缓存机制
    

# Ajax解决浏览器缓存问题
    1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since","0")。

    2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-cache")。

    3.在 URL 后面加上一个随机数："fresh=" + Math.random();。

    4.在 URL 后面加上时间戳："nowtime=" + new Date().getTime();。

    5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。

# 什么是浏览器的同源政策？
    理解：
        一个域下的js脚本未经允许下不能访问另一个域的内容
    同源：
        协议 域名  端口 必须相同 
    限制：
        1）不能访问其他域下的 cookie localStorage indexDB
        2）不能够操作访问其他域下的DOM
        3）ajax无法发送跨域请求

# 如何解决跨域问题？
    通过 jsonp 跨域
    document.domain + iframe 跨域
    location.hash + iframe
    window.name + iframe 跨域
    postMessage 跨域
    跨域资源共享（CORS)
    nginx 代理跨域
    nodejs 中间件代理跨域
    WebSocket 协议跨域

    解决跨域的方法我们可以根据我们想要实现的目的来划分。

    首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。

    （1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。
		如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。

    （2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，
		我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。

    （3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，
		这种方式的好处是可以传输的数据量大。

    （4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。

		如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。

    （5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，
		然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。

    （6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，
		浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。
		浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。

    非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。

    （7）使用 websocket 协议，这个协议没有同源限制。

    （8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。
# 